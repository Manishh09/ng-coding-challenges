{
  "version": "1.0.0",
  "lastUpdated": "2025-11-30T00:00:00Z",
  "baseRepository": "https://github.com/Manishh09/ng-coding-challenges/blob/develop",
  "defaultAuthor": {
    "name": "Manish Boge",
    "avatar": "https://avatars.githubusercontent.com/u/46419064?v=4",
    "profileUrl": "https://github.com/Manishh09"
  },
  "challenges": {
    "rxjs-api": {
      "fetch-products": {
        "id": 1,
        "isNew": false,
        "slug": "fetch-products",
        "title": "Challenge 01: Fetch Products",
        "categoryId": "rxjs-api",
        "difficulty": "Beginner",
        "enabled": true,
        "order": 1,
        "description": "Fetch product data from a fake API and display it in a table using Angular's HttpClient and RxJS.",
        "longDescription": "This challenge introduces you to Angular's HttpClient module and RxJS observables. You'll learn how to fetch data from a REST API and display it in a structured format. This is a fundamental skill for any Angular developer working with backend services.",
        "tags": [
          "HttpClient",
          "API",
          "RxJS",
          "Observables"
        ],
        "estimatedTime": "20-30 minutes",
        "prerequisites": [
          "Basic Angular knowledge",
          "TypeScript fundamentals"
        ],
        "learningOutcomes": [
          "Set up HttpClient in Angular standalone applications",
          "Make GET requests to REST APIs",
          "Handle observables with async pipe",
          "Display API data in tables",
          "Implement loading and error states"
        ],
        "requirementList": [
          "Create a service using HttpClient to fetch products from the Fake Store API endpoint: https://fakestoreapi.com/products.",
          "Develop a component to display the list of products in a table format with columns for Product Name, Price, and Category.",
          "Implement loading indicators while fetching data and error handling for failed requests."
        ],
        "links": {
          "requirement": "projects/ngc-rxjs-api/src/app/challenges/challenge-01-product-list/docs/CH-01-REQUIREMENT.md",
          "solution": "projects/ngc-rxjs-api/src/app/challenges/challenge-01-product-list/docs/CH-01-SOLUTION_GUIDE.md",
          "github": "projects/ngc-rxjs-api/src/app/challenges/challenge-01-product-list"
        },
        "workspace": {
          "componentPath": "./challenges/challenge-01-product-list/components/product-list/product-list.component",
          "componentName": "ProductListComponent"
        }
      },
      "handle-parallel-apis": {
        "id": 2,
        "isNew": false,
        "slug": "handle-parallel-apis",
        "title": "Challenge 02: Dashboard Data - Parallel API Calls",
        "categoryId": "rxjs-api",
        "difficulty": "Intermediate",
        "enabled": true,
        "order": 2,
        "description": "Perform parallel API calls in Angular using RxJS's forkJoin and display combined dashboard data.",
        "longDescription": "Master parallel API calls using RxJS's forkJoin operator. This challenge simulates a real-world dashboard scenario where you need to fetch data from multiple endpoints simultaneously and combine the results efficiently.",
        "tags": [
          "forkJoin",
          "Parallel APIs",
          "RxJS"
        ],
        "estimatedTime": "30-45 minutes",
        "prerequisites": [
          "Challenge 01 completed",
          "Understanding of Observables"
        ],
        "learningOutcomes": [
          "Use forkJoin for parallel API calls",
          "Combine multiple observable streams",
          "Handle loading states for multiple requests",
          "Manage errors in parallel operations",
          "Optimize API call performance"
        ],
        "requirementList": [
          "Fetch post details from /posts endpoint.",
          "Fetch user details data from /users endpoint.",
          "Combine all fetched data and display in a unified dashboard view."
        ],
        "links": {
          "requirement": "projects/ngc-rxjs-api/src/app/challenges/challenge-02-parallel-apis/docs/CH-02-REQUIREMENT.md",
          "solution": "projects/ngc-rxjs-api/src/app/challenges/challenge-02-parallel-apis/docs/CH-02-SOLUTION_GUIDE.md",
          "github": "projects/ngc-rxjs-api/src/app/challenges/challenge-02-parallel-apis"
        },
        "workspace": {
          "componentPath": "./challenges/challenge-02-parallel-apis/components/dashboard/dashboard.component",
          "componentName": "DashboardComponent"
        }
      },
      "client-side-search": {
        "id": 3,
        "isNew": false,
        "slug": "client-side-search",
        "title": "Challenge 03: Client-Side User Search",
        "categoryId": "rxjs-api",
        "difficulty": "Intermediate",
        "enabled": true,
        "order": 3,
        "description": "Implement a client-side search using Angular Reactive Forms and RxJS with dummy user data.",
        "longDescription": "Build a client-side search feature using Angular Reactive Forms and RxJS operators. Learn how to filter data efficiently without making API calls for every keystroke.",
        "tags": [
          "Reactive Forms",
          "Search",
          "Filtering"
        ],
        "estimatedTime": "30-45 minutes",
        "prerequisites": [
          "Reactive Forms basics",
          "Array manipulation in JavaScript"
        ],
        "learningOutcomes": [
          "Create reactive forms in Angular",
          "Implement client-side filtering",
          "Use RxJS operators for search optimization",
          "Handle form value changes reactively",
          "Build responsive search interfaces"
        ],
        "requirementList": [
          "Implement a search form using Angular Reactive Forms.",
          "Fetch product data from the API based on user input.",
          "Debounce user input to optimize API calls.",
          "Display search results in real-time as the user types."
        ],
        "links": {
          "requirement": "projects/ngc-rxjs-api/src/app/challenges/challenge-03-client-side-search/docs/CH-03-REQUIREMENT.md",
          "solution": "projects/ngc-rxjs-api/src/app/challenges/challenge-03-client-side-search/docs/CH-03-SOLUTION_GUIDE.md",
          "github": "projects/ngc-rxjs-api/src/app/challenges/challenge-03-client-side-search"
        },
        "workspace": {
          "componentPath": "./challenges/challenge-03-client-side-search/components/client-side-search/client-side-search.component",
          "componentName": "ClientSideSearchComponent"
        }
      },
      "server-side-search": {
        "id": 4,
        "isNew": false,
        "slug": "server-side-search",
        "title": "Challenge 04: Server-Side User Search - AutoComplete",
        "categoryId": "rxjs-api",
        "difficulty": "Advanced",
        "enabled": true,
        "order": 4,
        "description": "Implement a server-side search ( auto-complete / typeahead ) using Angular Reactive Forms and RxJS with an API backend.",
        "longDescription": "Implement a professional autocomplete search feature that queries a backend API. Learn critical RxJS operators like debounceTime, distinctUntilChanged, and switchMap to create a performant search experience.",
        "tags": [
          "AutoComplete",
          "debounceTime",
          "switchMap",
          "API"
        ],
        "estimatedTime": "45-60 minutes",
        "prerequisites": [
          "Challenge 03 completed",
          "Understanding of RxJS operators"
        ],
        "learningOutcomes": [
          "Implement debounced search queries",
          "Use switchMap for request cancellation",
          "Handle rapid user input efficiently",
          "Create autocomplete UI components",
          "Optimize API call frequency"
        ],
        "requirementList": [
          "Implement a search form using Angular Reactive Forms.",
          "Fetch product data from the API based on user input.",
          "Debounce user input to optimize API calls.",
          "Display search results in real-time as the user types."
        ],
        "links": {
          "requirement": "projects/ngc-rxjs-api/src/app/challenges/challenge-04-server-side-search/docs/CH-04-REQUIREMENT.md",
          "solution": "projects/ngc-rxjs-api/src/app/challenges/challenge-04-server-side-search/docs/CH-04-SOLUTION_GUIDE.md",
          "github": "projects/ngc-rxjs-api/src/app/challenges/challenge-04-server-side-search"
        },
        "workspace": {
          "componentPath": "./challenges/challenge-04-server-side-search/components/server-side-search/server-side-search.component",
          "componentName": "ServerSideSearchComponent"
        }
      },
      "product-category-management": {
        "id": 5,
        "isNew": false,
        "slug": "product-category-management",
        "title": "Challenge 05: Product Category Management - shareReplay",
        "categoryId": "rxjs-api",
        "difficulty": "Advanced",
        "enabled": true,
        "order": 5,
        "description": "Build a product category management system where multiple components share category data using Signals and RxJS shareReplay.",
        "longDescription": "Build a product category management system that demonstrates efficient data sharing between components. Learn how to use shareReplay to cache API responses and Angular Signals for reactive state management.",
        "tags": [
          "shareReplay",
          "Caching",
          "Signals"
        ],
        "estimatedTime": "45-60 minutes",
        "prerequisites": [
          "Understanding of Signals",
          "RxJS multicasting concepts"
        ],
        "learningOutcomes": [
          "Implement data caching with shareReplay",
          "Share data across multiple components",
          "Integrate Angular Signals with RxJS",
          "Optimize API call performance",
          "Build reactive component architectures"
        ],
        "requirementList": [
          "Implement data caching with shareReplay operator",
          "Build product-category dashboard sharing data across components",
          "Integrate Angular Signals with RxJS for reactive architecture"
        ],
        "links": {
          "requirement": "projects/ngc-rxjs-api/src/app/challenges/challenge-05-product-category-management-system/docs/CH-05-REQUIREMENT.md",
          "solution": "projects/ngc-rxjs-api/src/app/challenges/challenge-05-product-category-management-system/docs/CH-05-SOLUTION_GUIDE.md",
          "github": "projects/ngc-rxjs-api/src/app/challenges/challenge-05-product-category-management-system"
        },
        "workspace": {
          "componentPath": "./challenges/challenge-05-product-category-management-system/components/product-category-dashboard/product-category-dashboard.component",
          "componentName": "ProductCategoryDashboardComponent"
        }
      },
      "user-todos-filter": {
        "id": 6,
        "isNew": false,
        "slug": "user-todos-filter",
        "title": "Challenge 06: User Todos with Status Filter - combineLatest",
        "categoryId": "rxjs-api",
        "difficulty": "Intermediate",
        "enabled": true,
        "order": 6,
        "description": "Fetch todos and users from an API, merge them using RxJS combineLatest, and display an enriched table with status filters.",
        "longDescription": "Create a todo management system that combines data from multiple sources and provides dynamic filtering. Master the combineLatest operator to synchronize multiple data streams.",
        "tags": [
          "combineLatest",
          "Data Merging",
          "Filtering"
        ],
        "estimatedTime": "30-45 minutes",
        "prerequisites": [
          "Understanding of combineLatest",
          "Data transformation skills"
        ],
        "learningOutcomes": [
          "Use combineLatest for data synchronization",
          "Merge data from multiple API endpoints",
          "Implement dynamic filtering logic",
          "Create enriched data models",
          "Build complex reactive data flows"
        ],
        "requirementList": [
          "Fetch and combine todos with user data using RxJS operators",
          "Implement status filter (All, Completed, Pending)",
          "Display enriched todo list with user names in table format"
        ],
        "links": {
          "requirement": "projects/ngc-rxjs-api/src/app/challenges/challenge-06-user-todos-filter/docs/CH-06-REQUIREMENT.md",
          "solution": "projects/ngc-rxjs-api/src/app/challenges/challenge-06-user-todos-filter/docs/CH-06-SOLUTION_GUIDE.md",
          "github": "projects/ngc-rxjs-api/src/app/challenges/challenge-06-user-todos-filter"
        },
        "workspace": {
          "componentPath": "./challenges/challenge-06-user-todos-filter/components/user-todos/user-todos.component",
          "componentName": "UserTodosComponent"
        }
      },
      "user-posts-dashboard": {
        "id": 7,
        "isNew": false,
        "slug": "user-posts-dashboard",
        "title": "Challenge 07: User Posts Dashboard - Dependent API Calls",
        "categoryId": "rxjs-api",
        "difficulty": "Advanced",
        "enabled": true,
        "order": 7,
        "description": "Fetch users and their posts from DummyJSON API using RxJS mergeMap to handle dependent API calls.",
        "longDescription": "Tackle dependent API calls where the result of one request determines the next. Learn to use mergeMap (flatMap) to handle nested observables and create complex data flows for a user posts dashboard.",
        "tags": [
          "mergeMap",
          "Dependent APIs",
          "Nested Observables"
        ],
        "estimatedTime": "45-60 minutes",
        "prerequisites": [
          "Understanding of higher-order observables",
          "Advanced RxJS operators"
        ],
        "learningOutcomes": [
          "Handle dependent API calls with mergeMap",
          "Flatten nested observables",
          "Manage complex asynchronous flows",
          "Build hierarchical data structures",
          "Optimize nested request patterns"
        ],
        "requirementList": [
          "Fetch users from /users endpoint",
          "For each user, fetch their posts using mergeMap",
          "Display combined user-posts dashboard with proper error handling"
        ],
        "links": {
          "requirement": "projects/ngc-rxjs-api/src/app/challenges/challenge-07-dependent-apis/docs/CH-07-REQUIREMENT.md",
          "solution": "projects/ngc-rxjs-api/src/app/challenges/challenge-07-dependent-apis/docs/CH-07-SOLUTION_GUIDE.md",
          "github": "projects/ngc-rxjs-api/src/app/challenges/challenge-07-dependent-apis"
        },
        "workspace": {
          "componentPath": "./challenges/challenge-07-dependent-apis/components/user-posts-dashboard/user-posts-dashboard.component",
          "componentName": "UserPostsDashboardComponent"
        }
      },
      "ecommerce-checkout": {
        "id": 8,
        "isNew": false,
        "slug": "ecommerce-checkout",
        "title": "Challenge 08: E-Commerce Checkout Process - Sequential API Calls",
        "categoryId": "rxjs-api",
        "difficulty": "Advanced",
        "enabled": true,
        "order": 8,
        "description": "Implement a simplified e-commerce checkout process in Angular using RxJS to manage sequential API calls.",
        "longDescription": "Implement a multi-step checkout process with sequential API calls. Learn to use concatMap to ensure operations happen in order, handle errors gracefully, and manage complex state throughout the checkout flow.",
        "tags": [
          "concatMap",
          "Sequential APIs",
          "Error Handling"
        ],
        "estimatedTime": "45-60 minutes",
        "prerequisites": [
          "All previous RxJS challenges",
          "Understanding of concatMap vs mergeMap"
        ],
        "learningOutcomes": [
          "Implement sequential API operations with concatMap",
          "Handle multi-step form processes",
          "Manage transaction-like operations",
          "Implement comprehensive error handling",
          "Build state machines with RxJS"
        ],
        "requirementList": [
          "Build multi-step checkout form (Cart, Shipping, Payment, Confirmation)",
          "Implement sequential API calls using concatMap",
          "Handle cart validation, payment processing, and order confirmation",
          "Display step progress and handle errors at each stage"
        ],
        "links": {
          "requirement": "projects/ngc-rxjs-api/src/app/challenges/challenge-08-ecommerce-checkout/docs/CH-08-REQUIREMENT.md",
          "solution": "projects/ngc-rxjs-api/src/app/challenges/challenge-08-ecommerce-checkout/docs/CH-08-SOLUTION_GUIDE.md",
          "github": "projects/ngc-rxjs-api/src/app/challenges/challenge-08-ecommerce-checkout"
        },
        "workspace": {
          "componentPath": "./challenges/challenge-08-ecommerce-checkout/components/checkout/checkout.component",
          "componentName": "CheckoutComponent"
        }
      }
    },
    "angular-core": {
      "component-communication": {
        "id": 9,
        "isNew": false,
        "slug": "component-communication",
        "title": "Challenge 09: Component Communication using Signals",
        "categoryId": "angular-core",
        "difficulty": "Beginner",
        "enabled": true,
        "order": 1,
        "description": "Build a product dashboard demonstrating parent-child component communication using Angular Signals and standalone components.",
        "longDescription": "Master modern Angular component communication using Signals. Build a product dashboard with parent-child communication patterns, exploring input/output decorators and the new Signal-based APIs.",
        "tags": [
          "Signals",
          "Component Communication",
          "Input/Output"
        ],
        "estimatedTime": "20-30 minutes",
        "prerequisites": [
          "Angular Signals basics",
          "Standalone components"
        ],
        "learningOutcomes": [
          "Implement parent-child communication with Signals",
          "Use input() and output() functions",
          "Build standalone components",
          "Create reactive component architectures",
          "Handle component lifecycle with Signals"
        ],
        "requirementList": [
          "Create parent component managing product list with Signals",
          "Build child component receiving data via input() function",
          "Implement output() for parent-child communication on product selection"
        ],
        "links": {
          "requirement": "projects/ngc-core/src/app/challenges/challenge-09-component-communication/docs/CH-09-REQUIREMENT.md",
          "solution": "projects/ngc-core/src/app/challenges/challenge-09-component-communication/docs/CH-09-SOLUTION_GUIDE.md",
          "github": "projects/ngc-core/src/app/challenges/challenge-09-component-communication"
        },
        "workspace": {
          "componentPath": "./challenges/challenge-09-component-communication/components/product-dashboard/product-dashboard.component",
          "componentName": "ProductDashboardComponent"
        }
      }
    },
    "angular-routing": {
      "authorized-resource-access": {
        "id": 10,
        "isNew": false,
        "slug": "authorized-resource-access",
        "title": "Challenge 10: Authorized Resource Access",
        "categoryId": "angular-routing",
        "difficulty": "Intermediate",
        "enabled": true,
        "order": 1,
        "description": "Implement a simple authentication system in Angular using Signals and route guards to protect authorized resources.",
        "longDescription": "Build a complete authentication system with protected routes. Learn to implement canActivate guards using functional guards and Signals to control access to authorized resources.",
        "tags": [
          "Route Guards",
          "Authentication",
          "canActivate"
        ],
        "estimatedTime": "30-45 minutes",
        "prerequisites": [
          "Angular Router basics",
          "Understanding of guards"
        ],
        "learningOutcomes": [
          "Implement functional route guards",
          "Create authentication services with Signals",
          "Protect routes with canActivate",
          "Handle login/logout flows",
          "Manage authentication state"
        ],
        "requirementList": [
          "Build login form managing authentication state with Signals",
          "Implement canActivate guard checking authentication status",
          "Configure routes: Login, Dashboard (protected), Public",
          "Redirect unauthorized users to Login page"
        ],
        "links": {
          "requirement": "projects/ngc-routing/src/app/challenges/challenge-10-authorized-resource-access/docs/CH-10-REQUIREMENT.md",
          "solution": "projects/ngc-routing/src/app/challenges/challenge-10-authorized-resource-access/docs/CH-10-SOLUTION_GUIDE.md",
          "github": "projects/ngc-routing/src/app/challenges/challenge-10-authorized-resource-access"
        },
        "workspace": {
          "componentPath": "./challenges/challenge-10-authorized-resource-access/components/product-list/product-list.component",
          "componentName": "ProductListComponent"
        }
      },
      "admin-dashboard-access": {
        "id": 11,
        "isNew": false,
        "slug": "admin-dashboard-access",
        "title": "Challenge 11: Admin Dashboard Access (RBAC)",
        "categoryId": "angular-routing",
        "difficulty": "Advanced",
        "enabled": true,
        "order": 2,
        "description": "Create an admin dashboard in Angular with role-based access control using Signals and route guards.",
        "longDescription": "Implement role-based access control (RBAC) for an admin dashboard. Learn advanced routing techniques including role-based guards, protecting multiple routes, and handling unauthorized access gracefully.",
        "tags": [
          "RBAC",
          "Route Guards",
          "Authorization"
        ],
        "estimatedTime": "45-60 minutes",
        "prerequisites": [
          "Challenge 10 completed",
          "Advanced routing concepts"
        ],
        "learningOutcomes": [
          "Implement role-based access control",
          "Create complex authorization logic",
          "Handle multiple user roles",
          "Build secure route hierarchies",
          "Implement redirect strategies"
        ],
        "requirementList": [
          "Build authentication system with role assignment (admin, user)",
          "Implement role-based canActivate guard",
          "Configure routes: Admin Dashboard, User Dashboard, Public, Unauthorized",
          "Redirect non-admin users attempting admin access"
        ],
        "links": {
          "requirement": "projects/ngc-routing/src/app/challenges/challenge-11-admin-dashboard-access/docs/CH-11-REQUIREMENT.md",
          "solution": "projects/ngc-routing/src/app/challenges/challenge-11-admin-dashboard-access/docs/CH-11-SOLUTION_GUIDE.md",
          "github": "projects/ngc-routing/src/app/challenges/challenge-11-admin-dashboard-access"
        },
        "workspace": {
          "componentPath": "./challenges/challenge-11-admin-dashboard-access/components/dashboard/dashboard.component",
          "componentName": "DashboardComponent"
        }
      },
      "unsaved-form-changes": {
        "id": 19,
        "isNew": false,
        "slug": "unsaved-form-changes",
        "title": "Challenge 19: Unsaved Changes Guard",
        "categoryId": "angular-routing",
        "difficulty": "Advanced",
        "enabled": true,
        "order": 3,
        "description": "Implement a canDeactivate route guard to prevent navigation when a form has unsaved changes, prompting users with a confirmation dialog.",
        "longDescription": "Protect users from losing their work by implementing a canDeactivate guard. Learn advanced routing concepts including component-guard communication, form state tracking, and handling multiple navigation scenarios. This challenge demonstrates enterprise-level patterns for preventing accidental data loss.",
        "tags": [
          "canDeactivate",
          "CanDeactivateFn",
          "Route Guards",
          "Form State",
          "Navigation Prevention",
          "UX Protection"
        ],
        "estimatedTime": "45-60 minutes",
        "prerequisites": [
          "Challenge 10 completed",
          "Understanding of reactive forms",
          "Knowledge of route guards"
        ],
        "learningOutcomes": [
          "Implement canDeactivate functional guards",
          "Create reusable guard interfaces",
          "Track form dirty/pristine states",
          "Handle browser refresh warnings",
          "Manage component-guard communication",
          "Implement confirmation dialogs"
        ],
        "requirementList": [
          "Implement canDeactivate guard with reusable component interface",
          "Build user form tracking dirty state and unsaved changes",
          "Show confirmation dialog before navigation with unsaved data",
          "Handle browser events (refresh/close) with beforeunload"
        ],
        "links": {
          "requirement": "projects/ngc-routing/src/app/challenges/challenge-19-unsaved-form-changes/docs/CH-19-REQUIREMENT.md",
          "solution": "projects/ngc-routing/src/app/challenges/challenge-19-unsaved-form-changes/docs/CH-19-SOLUTION_GUIDE.md",
          "github": "projects/ngc-routing/src/app/challenges/challenge-19-unsaved-form-changes"
        },
        "workspace": {
          "componentPath": "./challenges/challenge-19-unsaved-form-changes/components/user-form/user-form.component",
          "componentName": "UserFormComponent"
        }
      }
    },
    "angular-forms": {
      "reactive-login-form": {
        "id": 12,
        "isNew": false,
        "slug": "reactive-login-form",
        "title": "Challenge 12: Reactive Login Form",
        "categoryId": "angular-forms",
        "difficulty": "Beginner",
        "enabled": true,
        "order": 1,
        "description": "Build a reactive login form with email and password validation using Angular's FormGroup, FormControl, and built-in validators.",
        "longDescription": "Master the fundamentals of Angular Reactive Forms by building a production-ready login form. Learn how to use FormBuilder, implement built-in validators, display dynamic error messages, and manage form state effectively. This challenge covers essential skills every Angular developer needs for form handling.",
        "tags": [
          "Reactive Forms",
          "FormGroup",
          "FormControl",
          "Validators",
          "Form Validation"
        ],
        "estimatedTime": "30-45 minutes",
        "prerequisites": [
          "Basic Angular knowledge",
          "Understanding of TypeScript",
          "Familiarity with Angular components"
        ],
        "learningOutcomes": [
          "Create reactive forms using FormBuilder and FormGroup",
          "Implement built-in validators (required, email, minLength)",
          "Display dynamic error messages based on validation state",
          "Manage form state (valid, invalid, touched, dirty)",
          "Use Angular Signals for reactive state management",
          "Implement proper form submission handling"
        ],
        "requirementList": [
          "Build reactive login form with email and password fields",
          "Apply validators: required, email format, minLength(6)",
          "Display dynamic error messages on touch/submit",
          "Disable submit button when invalid and show success message"
        ],
        "links": {
          "requirement": "projects/ngc-forms/src/app/challenges/challenge-12-reactive-login-form/docs/CH-12-REQUIREMENT.md",
          "solution": "projects/ngc-forms/src/app/challenges/challenge-12-reactive-login-form/docs/CH-12-SOLUTION_GUIDE.md",
          "github": "projects/ngc-forms/src/app/challenges/challenge-12-reactive-login-form"
        },
        "workspace": {
          "componentPath": "./challenges/challenge-12-reactive-login-form/components/login-form/login-form.component",
          "componentName": "LoginFormComponent"
        }
      },
      "duplicate-project-name-validator": {
        "id": 13,
        "isNew": false,
        "slug": "duplicate-project-name-validator",
        "title": "Challenge 13: Duplicate Project Name Validator",
        "categoryId": "angular-forms",
        "difficulty": "Intermediate",
        "enabled": true,
        "order": 2,
        "description": "Implement a custom synchronous validator that prevents duplicate project names with case-insensitive comparison and whitespace normalization.",
        "longDescription": "Take your Angular form validation skills to the next level by creating a custom validator with business logic. Learn how to build reusable validator functions, implement normalization strategies, handle edit mode scenarios, and provide rich error messages. This challenge demonstrates real-world patterns used in production applications.",
        "tags": [
          "Custom Validators",
          "ValidatorFn",
          "Synchronous Validation",
          "Business Logic",
          "Normalization",
          "Dynamic Validators"
        ],
        "estimatedTime": "60-90 minutes",
        "prerequisites": [
          "Completed Challenge 12 or equivalent reactive forms experience",
          "Understanding of Angular validators",
          "TypeScript functions and closures",
          "Angular Signals basics"
        ],
        "learningOutcomes": [
          "Create custom ValidatorFn functions with factory pattern",
          "Implement string normalization for consistent comparison",
          "Handle create vs edit mode validation scenarios",
          "Update validators dynamically at runtime",
          "Structure detailed ValidationErrors objects",
          "Use Angular Signals for reactive state in services",
          "Apply separation of concerns in validator design"
        ],
        "requirementList": [
          "Create custom ValidatorFn factory checking duplicate names",
          "Implement normalization (case-insensitive, whitespace, special chars)",
          "Build ProjectService with Signals for state management",
          "Display real-time validation with normalized preview"
        ],
        "links": {
          "requirement": "projects/ngc-forms/src/app/challenges/challenge-13-duplicate-project-name-validator/docs/CH-13-REQUIREMENT.md",
          "solution": "projects/ngc-forms/src/app/challenges/challenge-13-duplicate-project-name-validator/docs/CH-13-SOLUTION_GUIDE.md",
          "github": "projects/ngc-forms/src/app/challenges/challenge-13-duplicate-project-name-validator"
        },
        "workspace": {
          "componentPath": "./challenges/challenge-13-duplicate-project-name-validator/components/project-form/project-form.component",
          "componentName": "ProjectFormComponent"
        }
      },
      "email-availability-check": {
        "id": 14,
        "isNew": false,
        "slug": "email-availability-check",
        "title": "Challenge 14: Email Availability Check (Custom Async Validator)",
        "categoryId": "angular-forms",
        "difficulty": "Advanced",
        "enabled": true,
        "order": 3,
        "description": "Implement a custom asynchronous validator that checks email availability via simulated API with debouncing, loading states, and proper error handling.",
        "longDescription": "Master asynchronous form validation in Angular by creating a custom async validator that simulates real-world API calls. Learn how to implement debouncing to optimize performance, handle loading states elegantly, cancel in-flight requests, and provide a seamless user experience during async validation. This challenge demonstrates production-ready patterns for server-side validation.",
        "tags": [
          "Async Validators",
          "AsyncValidatorFn",
          "RxJS",
          "debounceTime",
          "switchMap",
          "Loading States",
          "API Simulation"
        ],
        "estimatedTime": "45-60 minutes",
        "prerequisites": [
          "Completed Challenge 13 or equivalent custom validator experience",
          "Understanding of RxJS observables",
          "Knowledge of async/await patterns",
          "Familiarity with timer and delay operators"
        ],
        "learningOutcomes": [
          "Create custom AsyncValidatorFn functions returning Observables",
          "Use RxJS operators for debouncing and request cancellation",
          "Handle PENDING validation states in Angular forms",
          "Simulate API calls with realistic delays",
          "Display loading indicators during async validation",
          "Implement proper error handling in async validators",
          "Provide suggested alternatives in validation errors",
          "Optimize form performance with debouncing strategies"
        ],
        "requirementList": [
          "Create custom AsyncValidatorFn with simulated API delay",
          "Implement debouncing (500ms) and loading states",
          "Build EmailValidationService checking availability",
          "Display error messages with suggested alternatives"
        ],
        "links": {
          "requirement": "projects/ngc-forms/src/app/challenges/challenge-14-email-availability-check/docs/CH-14-REQUIREMENT.md",
          "solution": "projects/ngc-forms/src/app/challenges/challenge-14-email-availability-check/docs/CH-14-SOLUTION_GUIDE.md",
          "github": "projects/ngc-forms/src/app/challenges/challenge-14-email-availability-check"
        },
        "workspace": {
          "componentPath": "./challenges/challenge-14-email-availability-check/components/email-form/email-form.component",
          "componentName": "EmailFormComponent"
        }
      },
      "date-range-validation": {
        "id": 15,
        "isNew": false,
        "slug": "date-range-validation",
        "title": "Challenge 15: Date Range Validation (Cross-Field Validator)",
        "categoryId": "angular-forms",
        "difficulty": "Advanced",
        "enabled": true,
        "order": 4,
        "description": "Build a leave request form with cross-field date range validation ensuring end date is after start date, demonstrating FormGroup-level validators.",
        "longDescription": "Advance your Angular forms expertise by mastering cross-field validation patterns. Unlike individual field validators, this challenge teaches you to validate relationships between multiple fields at the FormGroup level. Learn to implement date range validation where the end date must be after the start date, handle edge cases, calculate derived values, and display group-level errors separately from control-level errors. Essential patterns for real-world forms.",
        "tags": [
          "Cross-Field Validation",
          "FormGroup Validators",
          "Date Validation",
          "ValidatorFn",
          "Leave Management",
          "Group Errors",
          "Computed Values"
        ],
        "estimatedTime": "45-60 minutes",
        "prerequisites": [
          "Completed Challenge 12, 13, or equivalent ReactiveFormsModule experience",
          "Understanding of FormBuilder and FormGroup",
          "Knowledge of ValidatorFn vs AsyncValidatorFn",
          "Familiarity with HTML5 date inputs"
        ],
        "learningOutcomes": [
          "Implement FormGroup-level validators vs control-level validators",
          "Validate relationships between multiple form fields",
          "Access multiple controls within a validator function",
          "Display FormGroup errors separately from control errors",
          "Handle date comparisons and calculations in validators",
          "Implement conditional error display (show only when both fields touched)",
          "Calculate derived values (total days) from form data",
          "Apply business rules (maximum days per leave type)",
          "Use native HTML5 date inputs with proper formatting"
        ],
        "requirementList": [
          "Create cross-field dateRangeValidator at FormGroup level",
          "Build leave request form (type, start date, end date, reason)",
          "Calculate total days and enforce leave type limits",
          "Display FormGroup errors and warnings conditionally"
        ],
        "links": {
          "requirement": "projects/ngc-forms/src/app/challenges/challenge-15-date-range-validation/docs/CH-15-REQUIREMENT.md",
          "solution": "projects/ngc-forms/src/app/challenges/challenge-15-date-range-validation/docs/CH-15-SOLUTION_GUIDE.md",
          "github": "projects/ngc-forms/src/app/challenges/challenge-15-date-range-validation"
        },
        "workspace": {
          "componentPath": "./challenges/challenge-15-date-range-validation/components/leave-form/leave-form.component",
          "componentName": "LeaveFormComponent"
        }
      },
      "dynamic-form-array": {
        "id": 16,
        "isNew": false,
        "slug": "dynamic-form-array",
        "title": "Challenge 16: Dynamic FormArray (Experience Section)",
        "categoryId": "angular-forms",
        "difficulty": "Advanced",
        "enabled": true,
        "order": 5,
        "description": "Create a dynamic work experience form using FormArray where users can add/remove multiple experience entries with nested FormGroups.",
        "longDescription": "Master dynamic form structures in Angular by implementing FormArray for managing variable-length lists of form controls. This challenge teaches you how to dynamically add and remove form entries, handle nested FormGroups within FormArray, implement array constraints, and build reusable factory patterns for creating form structures. Essential patterns for building scalable forms like job applications, shopping carts, or any scenario requiring dynamic form entries.",
        "tags": [
          "FormArray",
          "Dynamic Forms",
          "Nested FormGroups",
          "Factory Pattern",
          "Array Constraints",
          "Add/Remove Operations",
          "Computed Signals"
        ],
        "estimatedTime": "45-60 minutes",
        "prerequisites": [
          "Completed Challenge 12 or equivalent ReactiveFormsModule experience",
          "Understanding of FormBuilder and FormGroup",
          "Familiarity with Angular control flow (@for)",
          "Basic TypeScript array operations"
        ],
        "learningOutcomes": [
          "Create and manage FormArray for dynamic form controls",
          "Implement nested FormGroups within FormArray",
          "Build factory methods for consistent FormGroup creation",
          "Handle dynamic add/remove operations on form arrays",
          "Apply array length constraints (min/max entries)",
          "Access nested controls with at() and get() methods",
          "Iterate over FormArray controls in templates with @for",
          "Use computed signals for reactive calculations across array entries",
          "Implement proper type casting for FormArray",
          "Handle form validation across all array entries"
        ],
        "requirementList": [
          "Create FormArray with nested FormGroups for work experiences",
          "Implement Add/Remove operations with constraints (min 1, max 5)",
          "Build factory method for consistent FormGroup creation",
          "Calculate total years with computed signal and display entry counter"
        ],
        "links": {
          "requirement": "projects/ngc-forms/src/app/challenges/challenge-16-dynamic-form-array/docs/CH-16-REQUIREMENTS.md",
          "solution": "projects/ngc-forms/src/app/challenges/challenge-16-dynamic-form-array/docs/CH-16-SOLUTION_GUIDE.md",
          "github": "projects/ngc-forms/src/app/challenges/challenge-16-dynamic-form-array"
        },
        "workspace": {
          "componentPath": "./challenges/challenge-16-dynamic-form-array/components/experience-form/experience-form.component",
          "componentName": "ExperienceFormComponent"
        }
      },
      "custom-input-cva": {
        "id": 17,
        "isNew": false,
        "slug": "custom-input-cva",
        "title": "Challenge 17: Custom Input Field using ControlValueAccessor",
        "categoryId": "angular-forms",
        "difficulty": "Expert",
        "enabled": true,
        "order": 6,
        "description": "Build a reusable custom input component implementing ControlValueAccessor interface to work seamlessly with Angular's reactive forms.",
        "longDescription": "Master the art of creating truly reusable form controls in Angular by implementing the ControlValueAccessor interface. This challenge teaches you how to bridge the gap between Angular's reactive forms and custom components, enabling bidirectional data flow and seamless integration with formControlName. Learn the 4 essential CVA methods, understand when and why each is called, and grasp the data flow patterns that make your components work like native inputs. Essential knowledge for building component libraries and reusable form controls.",
        "tags": [
          "ControlValueAccessor",
          "Custom Form Controls",
          "NG_VALUE_ACCESSOR",
          "Reusable Components",
          "forwardRef",
          "Reactive Forms Integration",
          "Bidirectional Data Flow"
        ],
        "estimatedTime": "60 minutes",
        "prerequisites": [
          "Completed Challenge 12 or equivalent ReactiveFormsModule experience",
          "Understanding of FormBuilder and FormGroup",
          "Knowledge of @Input/@Output decorators",
          "Familiarity with Angular dependency injection"
        ],
        "learningOutcomes": [
          "Implement ControlValueAccessor interface with all 4 methods",
          "Configure NG_VALUE_ACCESSOR provider with forwardRef",
          "Understand bidirectional data flow: Form ↔ Component",
          "Handle writeValue() to receive values from parent form",
          "Implement registerOnChange() for Component → Form communication",
          "Implement registerOnTouched() for touch tracking",
          "Handle setDisabledState() for disabled state propagation",
          "Use custom controls with formControlName directive",
          "Validate at parent level (not inside CVA component)",
          "Display errors from parent form state"
        ],
        "requirementList": [
          "Implement ControlValueAccessor interface with all 4 methods",
          "Configure NG_VALUE_ACCESSOR provider with forwardRef",
          "Create reusable input component supporting multiple types",
          "Build demo form demonstrating bidirectional data flow and validation"
        ],
        "links": {
          "requirement": "projects/ngc-forms/src/app/challenges/challenge-17-custom-input-cva/docs/CH-17-REQUIREMENT.md",
          "solution": "projects/ngc-forms/src/app/challenges/challenge-17-custom-input-cva/docs/CH-17-SOLUTION_GUIDE.md",
          "github": "projects/ngc-forms/src/app/challenges/challenge-17-custom-input-cva"
        },
        "workspace": {
          "componentPath": "./challenges/challenge-16-custom-input-cva/components/demo-form/demo-form.component",
          "componentName": "DemoFormComponent"
        }
      },
      "server-driven-dynamic-form": {
        "id": 18,
        "isNew": false,
        "slug": "server-driven-dynamic-form",
        "title": "Challenge 18: Server-Driven Dynamic Form",
        "categoryId": "angular-forms",
        "difficulty": "Expert",
        "enabled": true,
        "order": 7,
        "description": "Build a form dynamically from JSON schema with runtime validators, supporting multiple field types (text, email, select, checkbox).",
        "longDescription": "Master the art of building dynamic forms in Angular by rendering forms from JSON configuration. Learn to construct FormGroups at runtime, implement a validator factory pattern that maps string-based configs to Angular validators, and conditionally render different field types. This pattern is essential for CMS platforms, multi-tenant applications, admin panels, and any scenario where form structure comes from a server. Understand the trade-offs between flexibility and type safety while building truly scalable form systems.",
        "tags": [
          "Dynamic Forms",
          "JSON Schema",
          "FormBuilder",
          "Runtime Form Construction",
          "Validator Factory",
          "Schema-Driven UI",
          "Scalability Patterns"
        ],
        "estimatedTime": "60 minutes",
        "prerequisites": [
          "Completed Challenge 12 or equivalent ReactiveFormsModule experience",
          "Understanding of FormBuilder and FormGroup",
          "Knowledge of Validators and ValidatorFn",
          "Familiarity with @switch control flow"
        ],
        "learningOutcomes": [
          "Build forms dynamically from JSON configuration",
          "Implement validator factory pattern for runtime validator mapping",
          "Map string-based configs to Angular ValidatorFn",
          "Render different field types conditionally with @switch",
          "Handle form submission with dynamic structure",
          "Apply scalability patterns for schema-driven UI",
          "Understand trade-offs: flexibility vs type safety",
          "Sort and order fields from schema configuration"
        ],
        "requirementList": [
          "Define interfaces: FormSchema, FieldConfig, ValidatorConfig",
          "Build FormGroup dynamically from JSON schema at runtime",
          "Implement validator factory mapping string configs to ValidatorFn",
          "Render multiple field types (text, email, number, select, checkbox) conditionally"
        ],
        "links": {
          "requirement": "projects/ngc-forms/src/app/challenges/challenge-18-server-driven-dynamic-form/docs/CH-18-REQUIREMENT.md",
          "solution": "projects/ngc-forms/src/app/challenges/challenge-18-server-driven-dynamic-form/docs/CH-18-SOLUTION_GUIDE.md",
          "github": "projects/ngc-forms/src/app/challenges/challenge-18-server-driven-dynamic-form"
        },
        "workspace": {
          "componentPath": "./challenges/challenge-18-server-driven-dynamic-form/components/dynamic-form/dynamic-form.component",
          "componentName": "DynamicFormComponent"
        }
      }
    },
    "angular-signals": {
    },
    "community": {
    }
  }
}

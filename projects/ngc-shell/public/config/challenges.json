{
  "version": "1.0.0",
  "lastUpdated": "2025-11-30T00:00:00Z",
  "baseRepository": "https://github.com/Manishh09/ng-coding-challenges/blob/develop",
  "defaultAuthor": {
    "name": "Manish Kumar",
    "avatar": "/assets/avatars/manish.jpg",
    "profileUrl": "https://github.com/Manishh09"
  },
  "challenges": {
    "rxjs-api": {
      "fetch-products": {
        "id": 1,
        "slug": "fetch-products",
      "title": "Challenge 01: Fetch Products",
      "categoryId": "rxjs-api",
      "difficulty": "Beginner",
      "enabled": true,
      "order": 1,
      "description": "Fetch product data from a fake API and display it in a table using Angular's HttpClient and RxJS.",
      "longDescription": "This challenge introduces you to Angular's HttpClient module and RxJS observables. You'll learn how to fetch data from a REST API and display it in a structured format. This is a fundamental skill for any Angular developer working with backend services.",
      "tags": [
        "HttpClient",
        "API",
        "RxJS",
        "Observables"
      ],
      "estimatedTime": "30-45 minutes",
      "prerequisites": [
        "Basic Angular knowledge",
        "TypeScript fundamentals"
      ],
      "learningOutcomes": [
        "Set up HttpClient in Angular standalone applications",
        "Make GET requests to REST APIs",
        "Handle observables with async pipe",
        "Display API data in tables",
        "Implement loading and error states"
      ],
      "requirementList": [
        "Create a service using HttpClient to fetch products from the Fake Store API endpoint: https://fakestoreapi.com/products.",
        "Develop a component to display the list of products in a table format with columns for Product Name, Price, and Category.",
        "Implement loading indicators while fetching data and error handling for failed requests."
      ],
      "links": {
        "requirement": "projects/ngc-rxjs-api/src/app/challenges/challenge-01-product-list/docs/CH-01-REQUIREMENT.md",
        "solution": "projects/ngc-rxjs-api/src/app/challenges/challenge-01-product-list/docs/CH-01-SOLUTION_GUIDE.md",
        "github": "projects/ngc-rxjs-api/src/app/challenges/challenge-01-product-list"
      },
      "workspace": {
        "componentPath": "./challenges/challenge-01-product-list/components/product-list/product-list.component",
        "componentName": "ProductListComponent"
      }
    },
    "handle-parallel-apis": {
      "id": 2,
      "slug": "handle-parallel-apis",
      "title": "Challenge 02: Dashboard Data - Parallel API Calls",
      "categoryId": "rxjs-api",
      "difficulty": "Intermediate",
      "enabled": true,
      "order": 2,
      "description": "Perform parallel API calls in Angular using RxJS's forkJoin and display combined dashboard data.",
      "longDescription": "Master parallel API calls using RxJS's forkJoin operator. This challenge simulates a real-world dashboard scenario where you need to fetch data from multiple endpoints simultaneously and combine the results efficiently.",
      "tags": [
        "forkJoin",
        "Parallel APIs",
        "RxJS"
      ],
      "estimatedTime": "45-60 minutes",
      "prerequisites": [
        "Challenge 01 completed",
        "Understanding of Observables"
      ],
      "learningOutcomes": [
        "Use forkJoin for parallel API calls",
        "Combine multiple observable streams",
        "Handle loading states for multiple requests",
        "Manage errors in parallel operations",
        "Optimize API call performance"
      ],
      "requirementList": [
        "Fetch product statistics from /products/stats endpoint.",
        "Fetch recent orders from /orders/recent endpoint.",
        "Fetch user activity data from /users/activity endpoint.",
        "Combine all fetched data and display in a unified dashboard view."
      ],
      "links": {
        "requirement": "projects/ngc-rxjs-api/src/app/challenges/challenge-02-parallel-apis/docs/CH-02-REQUIREMENT.md",
        "solution": "projects/ngc-rxjs-api/src/app/challenges/challenge-02-parallel-apis/docs/CH-02-SOLUTION_GUIDE.md",
        "github": "projects/ngc-rxjs-api/src/app/challenges/challenge-02-parallel-apis"
      },
      "workspace": {
        "componentPath": "./challenges/challenge-02-parallel-apis/components/dashboard/dashboard.component",
        "componentName": "DashboardComponent"
      }
    },
    "client-side-search": {
      "id": 3,
      "slug": "client-side-search",
      "title": "Challenge 03: Client-Side User Search",
      "categoryId": "rxjs-api",
      "difficulty": "Beginner",
      "enabled": true,
      "order": 3,
      "description": "Implement a client-side search using Angular Reactive Forms and RxJS with dummy user data.",
      "longDescription": "Build a client-side search feature using Angular Reactive Forms and RxJS operators. Learn how to filter data efficiently without making API calls for every keystroke.",
      "tags": [
        "Reactive Forms",
        "Search",
        "Filtering"
      ],
      "estimatedTime": "40-50 minutes",
      "prerequisites": [
        "Reactive Forms basics",
        "Array manipulation in JavaScript"
      ],
      "learningOutcomes": [
        "Create reactive forms in Angular",
        "Implement client-side filtering",
        "Use RxJS operators for search optimization",
        "Handle form value changes reactively",
        "Build responsive search interfaces"
      ],
      "requirementList": [
        "Implement a search form using Angular Reactive Forms.",
        "Fetch product data from the API based on user input.",
        "Debounce user input to optimize API calls.",
        "Display search results in real-time as the user types."
      ],
      "links": {
        "requirement": "projects/ngc-rxjs-api/src/app/challenges/challenge-03-client-side-search/docs/CH-03-REQUIREMENT.md",
        "solution": "projects/ngc-rxjs-api/src/app/challenges/challenge-03-client-side-search/docs/CH-03-SOLUTION_GUIDE.md",
        "github": "projects/ngc-rxjs-api/src/app/challenges/challenge-03-client-side-search"
      },
      "workspace": {
        "componentPath": "./challenges/challenge-03-client-side-search/components/client-side-search/client-side-search.component",
        "componentName": "ClientSideSearchComponent"
      }
    },
    "server-side-search": {
      "id": 4,
      "slug": "server-side-search",
      "title": "Challenge 04: Server-Side User Search (AutoComplete)",
      "categoryId": "rxjs-api",
      "difficulty": "Intermediate",
      "enabled": true,
      "order": 4,
      "description": "Implement a server-side search (auto-complete) using Angular Reactive Forms and RxJS with an API backend.",
      "longDescription": "Implement a professional autocomplete search feature that queries a backend API. Learn critical RxJS operators like debounceTime, distinctUntilChanged, and switchMap to create a performant search experience.",
      "tags": [
        "AutoComplete",
        "debounceTime",
        "switchMap",
        "API"
      ],
      "estimatedTime": "60-75 minutes",
      "prerequisites": [
        "Challenge 03 completed",
        "Understanding of RxJS operators"
      ],
      "learningOutcomes": [
        "Implement debounced search queries",
        "Use switchMap for request cancellation",
        "Handle rapid user input efficiently",
        "Create autocomplete UI components",
        "Optimize API call frequency"
      ],
      "requirementList": [
        "Implement a search form using Angular Reactive Forms.",
        "Fetch product data from the API based on user input.",
        "Debounce user input to optimize API calls.",
        "Display search results in real-time as the user types."
      ],
      "links": {
        "requirement": "projects/ngc-rxjs-api/src/app/challenges/challenge-04-server-side-search/docs/CH-04-REQUIREMENT.md",
        "solution": "projects/ngc-rxjs-api/src/app/challenges/challenge-04-server-side-search/docs/CH-04-SOLUTION_GUIDE.md",
        "github": "projects/ngc-rxjs-api/src/app/challenges/challenge-04-server-side-search"
      },
      "workspace": {
        "componentPath": "./challenges/challenge-04-server-side-search/components/server-side-search/server-side-search.component",
        "componentName": "ServerSideSearchComponent"
      }
    },
    "product-category-management": {
      "id": 5,
      "slug": "product-category-management",
      "title": "Challenge 05: Product Category Management - shareReplay",
      "categoryId": "rxjs-api",
      "difficulty": "Intermediate",
      "enabled": true,
      "order": 5,
      "description": "Build a product category management system where multiple components share category data using Signals and RxJS shareReplay.",
      "longDescription": "Build a product category management system that demonstrates efficient data sharing between components. Learn how to use shareReplay to cache API responses and Angular Signals for reactive state management.",
      "tags": [
        "shareReplay",
        "Caching",
        "Signals"
      ],
      "estimatedTime": "60-90 minutes",
      "prerequisites": [
        "Understanding of Signals",
        "RxJS multicasting concepts"
      ],
      "learningOutcomes": [
        "Implement data caching with shareReplay",
        "Share data across multiple components",
        "Integrate Angular Signals with RxJS",
        "Optimize API call performance",
        "Build reactive component architectures"
      ],
      "requirementList": [
        "Implement data caching with shareReplay",
        "Share data across multiple components",
        "Integrate Angular Signals with RxJS",
        "Optimize API call performance",
        "Build reactive component architectures"
      ],
      "links": {
        "requirement": "projects/ngc-rxjs-api/src/app/challenges/challenge-05-product-category-management-system/docs/CH-05-REQUIREMENT.md",
        "solution": "projects/ngc-rxjs-api/src/app/challenges/challenge-05-product-category-management-system/docs/CH-05-SOLUTION_GUIDE.md",
        "github": "projects/ngc-rxjs-api/src/app/challenges/challenge-05-product-category-management-system"
      },
      "workspace": {
        "componentPath": "./challenges/challenge-05-product-category-management-system/components/product-category-dashboard/product-category-dashboard.component",
        "componentName": "ProductCategoryDashboardComponent"
      }
    },
    "user-todos-filter": {
      "id": 6,
      "slug": "user-todos-filter",
      "title": "Challenge 06: User Todos with Status Filter - combineLatest",
      "categoryId": "rxjs-api",
      "difficulty": "Intermediate",
      "enabled": true,
      "order": 6,
      "description": "Fetch todos and users from an API, merge them using RxJS combineLatest, and display an enriched table with status filters.",
      "longDescription": "Create a todo management system that combines data from multiple sources and provides dynamic filtering. Master the combineLatest operator to synchronize multiple data streams.",
      "tags": [
        "combineLatest",
        "Data Merging",
        "Filtering"
      ],
      "estimatedTime": "75-90 minutes",
      "prerequisites": [
        "Understanding of combineLatest",
        "Data transformation skills"
      ],
      "learningOutcomes": [
        "Use combineLatest for data synchronization",
        "Merge data from multiple API endpoints",
        "Implement dynamic filtering logic",
        "Create enriched data models",
        "Build complex reactive data flows"
      ],
      "requirementList": [
        "Fetch todos from /todos endpoint and users from /users endpoint.",
        "Combine the data to create an enriched todo list with user names.",
        "Implement a status filter to view All, Completed, and Pending todos.",
        "Display the enriched and filtered todo list in a table format."
      ],
      "links": {
        "requirement": "projects/ngc-rxjs-api/src/app/challenges/challenge-06-user-todos-filter/docs/CH-06-REQUIREMENT.md",
        "solution": "projects/ngc-rxjs-api/src/app/challenges/challenge-06-user-todos-filter/docs/CH-06-SOLUTION_GUIDE.md",
        "github": "projects/ngc-rxjs-api/src/app/challenges/challenge-06-user-todos-filter"
      },
      "workspace": {
        "componentPath": "./challenges/challenge-06-user-todos-filter/components/user-todos/user-todos.component",
        "componentName": "UserTodosComponent"
      }
    },
    "user-posts-dashboard": {
      "id": 7,
      "slug": "user-posts-dashboard",
      "title": "Challenge 07: User Posts Dashboard - Dependent API Calls",
      "categoryId": "rxjs-api",
      "difficulty": "Advanced",
      "enabled": true,
      "order": 7,
      "description": "Fetch users and their posts from DummyJSON API using RxJS mergeMap to handle dependent API calls.",
      "longDescription": "Tackle dependent API calls where the result of one request determines the next. Learn to use mergeMap (flatMap) to handle nested observables and create complex data flows for a user posts dashboard.",
      "tags": [
        "mergeMap",
        "Dependent APIs",
        "Nested Observables"
      ],
      "estimatedTime": "90-120 minutes",
      "prerequisites": [
        "Understanding of higher-order observables",
        "Advanced RxJS operators"
      ],
      "learningOutcomes": [
        "Handle dependent API calls with mergeMap",
        "Flatten nested observables",
        "Manage complex asynchronous flows",
        "Build hierarchical data structures",
        "Optimize nested request patterns"
      ],
      "requirementList": [
        "Fetch the list of users from /users endpoint.",
        "For each user, fetch their posts from /posts?userId={userId} endpoint."
      ],
      "links": {
        "requirement": "projects/ngc-rxjs-api/src/app/challenges/challenge-07-dependent-apis/docs/CH-07-REQUIREMENT.md",
        "solution": "projects/ngc-rxjs-api/src/app/challenges/challenge-07-dependent-apis/docs/CH-07-SOLUTION_GUIDE.md",
        "github": "projects/ngc-rxjs-api/src/app/challenges/challenge-07-dependent-apis"
      },
      "workspace": {
        "componentPath": "./challenges/challenge-07-dependent-apis/components/user-posts-dashboard/user-posts-dashboard.component",
        "componentName": "UserPostsDashboardComponent"
      }
    },
    "ecommerce-checkout": {
      "id": 8,
      "slug": "ecommerce-checkout",
      "title": "Challenge 08: E-Commerce Checkout Process - Sequential API Calls",
      "categoryId": "rxjs-api",
      "difficulty": "Advanced",
      "enabled": true,
      "order": 8,
      "description": "Implement a simplified e-commerce checkout process in Angular using RxJS to manage sequential API calls.",
      "longDescription": "Implement a multi-step checkout process with sequential API calls. Learn to use concatMap to ensure operations happen in order, handle errors gracefully, and manage complex state throughout the checkout flow.",
      "tags": [
        "concatMap",
        "Sequential APIs",
        "Error Handling"
      ],
      "estimatedTime": "120-150 minutes",
      "prerequisites": [
        "All previous RxJS challenges",
        "Understanding of concatMap vs mergeMap"
      ],
      "learningOutcomes": [
        "Implement sequential API operations with concatMap",
        "Handle multi-step form processes",
        "Manage transaction-like operations",
        "Implement comprehensive error handling",
        "Build state machines with RxJS"
      ],
      "requirementList": [
        "Create a multi-step checkout form with steps for Cart Review, Shipping Info, Payment Info, and Order Confirmation.",
        "On form submission, perform the following API calls in sequence using concatMap:",
        "- Validate Cart: POST /checkout/validate",
        "- Process Payment: POST /checkout/payment",
        "- Confirm Order: POST /checkout/confirm"
      ],
      "links": {
        "requirement": "projects/ngc-rxjs-api/src/app/challenges/challenge-08-ecommerce-checkout/docs/CH-08-REQUIREMENT.md",
        "solution": "projects/ngc-rxjs-api/src/app/challenges/challenge-08-ecommerce-checkout/docs/CH-08-SOLUTION_GUIDE.md",
        "github": "projects/ngc-rxjs-api/src/app/challenges/challenge-08-ecommerce-checkout"
      },
      "workspace": {
        "componentPath": "./challenges/challenge-08-ecommerce-checkout/components/checkout/checkout.component",
        "componentName": "CheckoutComponent"
      }
    }
  },
  "angular-core": {
    "component-communication": {
      "id": 9,
      "slug": "component-communication",
      "title": "Challenge 09: Component Communication using Signals",
      "categoryId": "angular-core",
      "difficulty": "Beginner",
      "enabled": true,
      "order": 1,
      "description": "Build a product dashboard demonstrating parent-child component communication using Angular Signals and standalone components.",
      "longDescription": "Master modern Angular component communication using Signals. Build a product dashboard with parent-child communication patterns, exploring input/output decorators and the new Signal-based APIs.",
      "tags": [
        "Signals",
        "Component Communication",
        "Input/Output"
      ],
      "estimatedTime": "60-75 minutes",
      "prerequisites": [
        "Angular Signals basics",
        "Standalone components"
      ],
      "learningOutcomes": [
        "Implement parent-child communication with Signals",
        "Use input() and output() functions",
        "Build standalone components",
        "Create reactive component architectures",
        "Handle component lifecycle with Signals"
      ],
      "requirementList": [
        "Create a parent component that holds a list of products as a Signal.",
        "Develop a child component to display individual product details, receiving data via input().",
        "Implement an output() function in the child component to notify the parent when a product is selected."
      ],
      "links": {
        "requirement": "projects/ngc-core/src/app/challenges/challenge-09-component-communication/docs/CH-09-REQUIREMENT.md",
        "solution": "projects/ngc-core/src/app/challenges/challenge-09-component-communication/docs/CH-09-SOLUTION_GUIDE.md",
        "github": "projects/ngc-core/src/app/challenges/challenge-09-component-communication"
      },
      "workspace": {
        "componentPath": "./challenges/challenge-09-component-communication/components/product-dashboard/product-dashboard.component",
        "componentName": "ProductDashboardComponent"
      }
    }
  },
  "angular-routing": {
    "authorized-resource-access": {
      "id": 10,
      "slug": "authorized-resource-access",
      "title": "Challenge 10: Authorized Resource Access",
      "categoryId": "angular-routing",
      "difficulty": "Intermediate",
      "enabled": true,
      "order": 1,
      "description": "Implement a simple authentication system in Angular using Signals and route guards to protect authorized resources.",
      "longDescription": "Build a complete authentication system with protected routes. Learn to implement canActivate guards using functional guards and Signals to control access to authorized resources.",
      "tags": [
        "Route Guards",
        "Authentication",
        "canActivate"
      ],
      "estimatedTime": "90-120 minutes",
      "prerequisites": [
        "Angular Router basics",
        "Understanding of guards"
      ],
      "learningOutcomes": [
        "Implement functional route guards",
        "Create authentication services with Signals",
        "Protect routes with canActivate",
        "Handle login/logout flows",
        "Manage authentication state"
      ],
      "requirementList": [
        "Create a simple login form that updates an authentication Signal upon successful login.",
        "Implement a canActivate guard that checks the authentication Signal to allow or deny access to protected routes.",
        "Set up routes for Login, Dashboard (protected), and Public pages.",
        "Ensure unauthorized users are redirected to the Login page when trying to access protected routes."
      ],
      "links": {
        "requirement": "projects/ngc-routing/src/app/challenges/challenge-10-authorized-resource-access/docs/CH-10-REQUIREMENT.md",
        "solution": "projects/ngc-routing/src/app/challenges/challenge-10-authorized-resource-access/docs/CH-10-SOLUTION_GUIDE.md",
        "github": "projects/ngc-routing/src/app/challenges/challenge-10-authorized-resource-access"
      },
      "workspace": {
        "componentPath": "./challenges/challenge-10-authorized-resource-access/components/product-list/product-list.component",
        "componentName": "ProductListComponent"
      }
    },
    "admin-dashboard-access": {
      "id": 11,
      "slug": "admin-dashboard-access",
      "title": "Challenge 11: Admin Dashboard Access",
      "categoryId": "angular-routing",
      "difficulty": "Intermediate",
      "enabled": true,
      "order": 2,
      "description": "Create an admin dashboard in Angular with role-based access control using Signals and route guards.",
      "longDescription": "Implement role-based access control (RBAC) for an admin dashboard. Learn advanced routing techniques including role-based guards, protecting multiple routes, and handling unauthorized access gracefully.",
      "tags": [
        "RBAC",
        "Route Guards",
        "Authorization"
      ],
      "estimatedTime": "120-150 minutes",
      "prerequisites": [
        "Challenge 10 completed",
        "Advanced routing concepts"
      ],
      "learningOutcomes": [
        "Implement role-based access control",
        "Create complex authorization logic",
        "Handle multiple user roles",
        "Build secure route hierarchies",
        "Implement redirect strategies"
      ],
      "requirementList": [
        "Create a user authentication system that assigns roles (e.g., admin, user) upon login.",
        "Implement a canActivate guard that checks the user role Signal to allow or deny access to admin routes.",
        "Set up routes for Admin Dashboard (protected), User Dashboard (protected), and Public pages.",
        "Ensure users without the admin role are redirected to an Unauthorized page when trying to access admin routes."
      ],
      "links": {
        "requirement": "projects/ngc-routing/src/app/challenges/challenge-11-admin-dashboard-access/docs/CH-11-REQUIREMENT.md",
        "solution": "projects/ngc-routing/src/app/challenges/challenge-11-admin-dashboard-access/docs/CH-11-SOLUTION_GUIDE.md",
        "github": "projects/ngc-routing/src/app/challenges/challenge-11-admin-dashboard-access"
      },
      "workspace": {
        "componentPath": "./challenges/challenge-11-admin-dashboard-access/components/dashboard/dashboard.component",
        "componentName": "DashboardComponent"
      }
    }
  },
  "angular-forms": {
    "reactive-login-form": {
      "id": 12,
      "slug": "reactive-login-form",
      "title": "Challenge 12: Reactive Login Form",
      "categoryId": "angular-forms",
      "difficulty": "Beginner",
      "enabled": true,
      "order": 1,
      "description": "Build a reactive login form with email and password validation using Angular's FormGroup, FormControl, and built-in validators.",
      "longDescription": "Master the fundamentals of Angular Reactive Forms by building a production-ready login form. Learn how to use FormBuilder, implement built-in validators, display dynamic error messages, and manage form state effectively. This challenge covers essential skills every Angular developer needs for form handling.",
      "tags": [
        "Reactive Forms",
        "FormGroup",
        "FormControl",
        "Validators",
        "Form Validation"
      ],
      "estimatedTime": "30-45 minutes",
      "prerequisites": [
        "Basic Angular knowledge",
        "Understanding of TypeScript",
        "Familiarity with Angular components"
      ],
      "learningOutcomes": [
        "Create reactive forms using FormBuilder and FormGroup",
        "Implement built-in validators (required, email, minLength)",
        "Display dynamic error messages based on validation state",
        "Manage form state (valid, invalid, touched, dirty)",
        "Use Angular Signals for reactive state management",
        "Implement proper form submission handling"
      ],
      "requirementList": [
        "Create a LoginFormComponent with email and password fields using Angular Reactive Forms.",
        "Implement validation: email (required + valid format), password (required + minimum 6 characters).",
        "Display inline error messages that appear only after fields are touched or form is submitted.",
        "Disable the submit button when the form is invalid and show success message on valid submission."
      ],
      "links": {
        "requirement": "projects/ngc-forms/src/app/challenges/challenge-12-reactive-login-form/docs/CH-12-REQUIREMENT.md",
        "solution": "projects/ngc-forms/src/app/challenges/challenge-12-reactive-login-form/docs/CH-12-SOLUTION_GUIDE.md",
        "github": "projects/ngc-forms/src/app/challenges/challenge-12-reactive-login-form"
      },
      "workspace": {
        "componentPath": "./challenges/challenge-12-reactive-login-form/components/login-form/login-form.component",
        "componentName": "LoginFormComponent"
      }
    },
    "duplicate-project-name-validator": {
      "id": 13,
      "slug": "duplicate-project-name-validator",
      "title": "Challenge 13: Duplicate Project Name Validator",
      "categoryId": "angular-forms",
      "difficulty": "Intermediate",
      "enabled": true,
      "order": 2,
      "description": "Implement a custom synchronous validator that prevents duplicate project names with case-insensitive comparison and whitespace normalization.",
      "longDescription": "Take your Angular form validation skills to the next level by creating a custom validator with business logic. Learn how to build reusable validator functions, implement normalization strategies, handle edit mode scenarios, and provide rich error messages. This challenge demonstrates real-world patterns used in production applications.",
      "tags": [
        "Custom Validators",
        "ValidatorFn",
        "Synchronous Validation",
        "Business Logic",
        "Normalization",
        "Dynamic Validators"
      ],
      "estimatedTime": "60-90 minutes",
      "prerequisites": [
        "Completed Challenge 12 or equivalent reactive forms experience",
        "Understanding of Angular validators",
        "TypeScript functions and closures",
        "Angular Signals basics"
      ],
      "learningOutcomes": [
        "Create custom ValidatorFn functions with factory pattern",
        "Implement string normalization for consistent comparison",
        "Handle create vs edit mode validation scenarios",
        "Update validators dynamically at runtime",
        "Structure detailed ValidationErrors objects",
        "Use Angular Signals for reactive state in services",
        "Apply separation of concerns in validator design"
      ],
      "requirementList": [
        "Create a reusable duplicateNameValidator factory function that returns a ValidatorFn.",
        "Implement normalization: case-insensitive, trim whitespace, treat spaces/hyphens as equivalent.",
        "Support edit mode by excluding the current project name from duplicate checking.",
        "Display real-time validation with normalized preview and clear error messages.",
        "Build a ProjectService with Angular Signals managing CRUD operations and computed project names.",
        "Create mode toggle allowing users to switch between create and edit modes with dynamic validator updates."
      ],
      "links": {
        "requirement": "projects/ngc-forms/src/app/challenges/challenge-13-duplicate-project-name-validator/docs/CH-13-REQUIREMENT.md",
        "solution": "projects/ngc-forms/src/app/challenges/challenge-13-duplicate-project-name-validator/docs/CH-13-SOLUTION_GUIDE.md",
        "github": "projects/ngc-forms/src/app/challenges/challenge-13-duplicate-project-name-validator"
      },
      "workspace": {
        "componentPath": "./challenges/challenge-13-duplicate-project-name-validator/components/project-form/project-form.component",
        "componentName": "ProjectFormComponent"
      }
    },
    "email-availability-check": {
      "id": 14,
      "slug": "email-availability-check",
      "title": "Challenge 14: Email Availability Check (Custom Async Validator)",
      "categoryId": "angular-forms",
      "difficulty": "Advanced",
      "enabled": true,
      "order": 3,
      "description": "Implement a custom asynchronous validator that checks email availability via simulated API with debouncing, loading states, and proper error handling.",
      "longDescription": "Master asynchronous form validation in Angular by creating a custom async validator that simulates real-world API calls. Learn how to implement debouncing to optimize performance, handle loading states elegantly, cancel in-flight requests, and provide a seamless user experience during async validation. This challenge demonstrates production-ready patterns for server-side validation.",
      "tags": [
        "Async Validators",
        "AsyncValidatorFn",
        "RxJS",
        "debounceTime",
        "switchMap",
        "Loading States",
        "API Simulation"
      ],
      "estimatedTime": "60-90 minutes",
      "prerequisites": [
        "Completed Challenge 13 or equivalent custom validator experience",
        "Understanding of RxJS observables",
        "Knowledge of async/await patterns",
        "Familiarity with timer and delay operators"
      ],
      "learningOutcomes": [
        "Create custom AsyncValidatorFn functions returning Observables",
        "Use RxJS operators for debouncing and request cancellation",
        "Handle PENDING validation states in Angular forms",
        "Simulate API calls with realistic delays",
        "Display loading indicators during async validation",
        "Implement proper error handling in async validators",
        "Provide suggested alternatives in validation errors",
        "Optimize form performance with debouncing strategies"
      ],
      "requirementList": [
        "Create an asyncEmailAvailabilityValidator factory function returning AsyncValidatorFn.",
        "Implement EmailValidationService with simulated API using 1.5 second delay.",
        "Use debounceTime(500ms) to reduce validation calls during typing.",
        "Show loading spinner while validation status is PENDING.",
        "Display clear error messages for taken emails with suggested alternatives.",
        "Handle API errors gracefully with catchError (fail-open strategy).",
        "Register async validator in third parameter of FormControl array.",
        "Monitor statusChanges observable to track PENDING state."
      ],
      "links": {
        "requirement": "projects/ngc-forms/src/app/challenges/challenge-14-email-availability-check/docs/CH-14-REQUIREMENT.md",
        "solution": "projects/ngc-forms/src/app/challenges/challenge-14-email-availability-check/docs/CH-14-SOLUTION_GUIDE.md",
        "github": "projects/ngc-forms/src/app/challenges/challenge-14-email-availability-check"
      },
      "workspace": {
        "componentPath": "./challenges/challenge-14-email-availability-check/components/email-form/email-form.component",
        "componentName": "EmailFormComponent"
      }
    }
  }
}
}
